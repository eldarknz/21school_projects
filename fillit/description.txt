• main()
    Начальная точка ввода для программы.
    Вызывает read_data(), чтобы вернуть список частей (и определить, является ли файл правильным).
    Вызывает solve(), чтобы решить головоломку.
    Вызывает print_map() для печати решенной головоломки.
    Вызывает free_map() для освобождения карты.
    Вызывает free_list() для освобождения списка предметов.

    Вход: аргументы из стандартного ввода
    Выход: -

    • read_data ()
        Вызывает open() для filename, чтобы получить fd.
        Вызывает read(), чтобы прочитать файл и копирует их в buf.
        Если количество байт больше 544 или меньше 19, то возвращает NULL и выводит ошибку.
        Вызывает check_figure() для проверки фигур.
        Вызывает вызывает() в цикле, чтобы прочитать файл и вернуть части.
        Добавляет каждый новый кусок в список.
        Закрывает фд.
        Возвращает ошибку, если неверный файл.
   
        Ввод: имя файла в виде строки
        Вывод: указатель t_list на начало списка элементов

        • check_figure()
            Получает buf и количество байт, переданные из read_data().
            В цикле через каждые 21 байт, что соответсвтует одной фигуре проверяет на валидность
            с помощью функций character_count() и neighbor_counter().

            • character_counter()
                Проверяет содержание в фигуру 4 символов '#'.
                Проверяет содержание в фигуре символы, отличные от '.', '#' И '\ n'.
                Валидные тетромино будут содержать либо 6, либо 8 (8 для квадрата) смежных символов.            

            • neighbor_counter()
                Проверяет, имеет ли фигура допустимое количество смежных символов (#).
                Валидные тетромино будут содержать либо 6, либо 8 (8 для квадрата) смежных символов.

        • create_figure_list()
            Читает буфер, чтобы создать фигуру с помощью create_figure().
            Использует ограничения по размеру.

            • VALID_CHECKER ()
                Проверяет, является ли файл действительным.
                Файл недействителен, если ([x] указывает, что уже проверено в анализаторе):
                    [x] Менее 21 байта
                    - Часть куска не содержит 4 символа '#ß'
                    - adjacency_counter () возврат не 6 или 8
                    - Строки длиной более 4 символов (исключая '\ n')
                    - штучные блоки длиной более 4 строк
                    - Содержит символы, отличные от '.', '#' И '\ n'
                    - Содержит недействительные части
                    [x] Больше 544 байтов

                    • ADJACENCY_COUNTER ()
                        Проверяет, имеет ли кусок допустимое количество смежностей.
                        Действительные тетромино будут содержать либо 6, либо 8 (8, если мало квадратичных) смежностей.
   
    • solver()
        Вызывает get_map_size(), чтобы получить размер карты
        Вызывает new_map() для создания новой пустой карты
        Вызывает build_map() в цикле, чтобы начать рекурсивную реализацию возврата.
        В случае невозможности решиния карты, увеличивает размер карты и создает новую
        В случае успешной отрисовки возвращает решенную карту.

        • build_map()
            Вызывается рекурсивно.
            Пока фигура не вылезает за граинцы карты, проверяет пересечение, если все ок, то вызывает insert_figure(), чтобы добавить фигуру на карту.
            Если insert_figure() не выполянется, то свдигаем фигуру на один столбец.
            Если insert_figure() выполняется, то вызываем build_map() со следующей фигурой.
            Если insert_figure() не выполянется для ВСЕХ фигур, то возвращаяемся к предыдущей фигуры и перемещаем на 1 строку.
            Повторяем, пока не найдем решением.
            Возвращаем заполненную карту.

• print_map()
     Печатает решенную карту.

• free_map()
     Освобождает карту.

• free_list()
     Освобождает список фигур
