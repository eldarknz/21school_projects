• ОСНОВНОЙ()
    Начальная точка ввода для программы.
    Вызывает parser (), чтобы вернуть список частей (и определить, является ли файл правильным).
    Вызывает решатель (), чтобы решить головоломку.
    Вызывает map_printer () для печати решенной головоломки.
    Вызывает free_map () для освобождения карты.
    Вызывает free_pieces () для освобождения списка предметов.

    Вход: аргументы из стандартного ввода
    Выход: -

    • PARSER ()
        Вызывает open () для filestring, чтобы получить fd.
        Вызывает piecemaker () в цикле, чтобы прочитать файл и вернуть части.
        Добавляет каждый новый кусок в список.
        Закрывает фд.
        Возвращает ошибку, если неверный файл.
   
        Ввод: имя файла в виде строки
        Вывод: указатель t_list на начало списка элементов

        • PIECEMAKER ()
            Читает данный раздел буфера, чтобы создать структуру t_piece.
            Использует ограничения по размеру и вызывает valid_checker () во время чтения, чтобы проверить, является ли файл правильным.

            Вход: символ * начало фрагмента, символ * конец фрагмента
            Вывод: указатель t_piece на новый фрагмент

            • VALID_CHECKER ()
                Проверяет, является ли файл действительным.
                Файл недействителен, если ([x] указывает, что уже проверено в анализаторе):
                    [x] Менее 21 байта
                    - Часть куска не содержит 4 символа '#'
                    - adjacency_counter () возврат не 6 или 8
                    - Строки длиной более 4 символов (исключая '\ n')
                    - штучные блоки длиной более 4 строк
                    - Содержит символы, отличные от '.', '#' И '\ n'
                    - Содержит недействительные части
                    [x] Больше 544 байтов

                    • ADJACENCY_COUNTER ()
                        Проверяет, имеет ли кусок допустимое количество смежностей.
                        Действительные тетромино будут содержать либо 6, либо 8 (8, если мало квадратичных) смежностей.
   
    • SOLVER ()
        Вызывает mapper () для создания пустой карты.
        Вызывает fitter () в цикле, чтобы начать рекурсивную реализацию возврата.
        В то время как fitter () не работает, увеличивает размер пустой карты.
        Возвращает решенный mapp, когда fitter () успешно.

        Ввод: заголовок списка элементов (указатель t_list)
        Вывод: решена карта в виде двумерного массива

        • ФИТТЕР ()
            >> РЕКУРСИВНОЕ ВРЕМЯ ОБРАТНОЙ СВЯЗИ! <<
            Пока фигура не касается края, вызовите функцию placer (), чтобы добавить фигуру на карту.
            Если placer () неудачен, переместите часть 1 на карту вперед.
            Если placer () успешен, вызовите fitter () на следующем фрагменте
            Если placer () не подходит для ВСЕХ размещений следующего фрагмента, вернитесь к предыдущему фрагменту и переместитесь на 1 пробел вперед.
            Повторяйте, пока действительная карта не будет найдена.
            Вернуть решенную карту.

            • PLACER ()
                  Проверяет правильность текущей позиции фигуры (без пересечений с другими фигурами).
                  Если нет, верните (0).
                  Если да, помещает кусок, вызывает letterer () для замены символов «#» буквой, соответствующей номеру элемента.
                     - отследите, сколько штук, так как letterer () должен заполняться разными буквами для каждого!

                  Входные данные: указатель структуры фигуры Тетриса, указатель карты, координата x, координата y.
                  Вывод: целое число (флаг успеха или неудачи)

                 • ПИСЬМО ()
                     Заменяет данные символы «#» тетромино на данную букву.

                     Вход: Tetris кусок структуры указатель, символ
                     Вывод: Tetris кусок структуры указатель

• MAP_PRINTER ()
     Печатает решенную карту.

• FREE_MAP ()
     Освобождает массив 2D карты.

• FREE_PIECES ()
     Освобождает список произведений malloc.
